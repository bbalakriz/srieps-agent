from robusta.api import *
import requests
import os
import re

# SREIPS Agent API endpoint - externalized
SREIPS_AGENT_URL = os.getenv("SREIPS_AGENT_URL", "http://sreips-agent.sreips-agent.svc.cluster.local:8000")

# Prompt mapping based on common Kubernetes failure reasons
# Using concise, search-optimized queries for better agent performance
PROMPT_MAPPINGS = {
    "CrashLoopBackOff": "CrashLoopBackOff OpenShift pod",
    "ImagePullBackOff": "ImagePullBackOff pod OpenShift",
    "ErrImagePull": "image pull error OpenShift container",
    "CreateContainerConfigError": "container configuration error OpenShift",
    "InvalidImageName": "invalid image name OpenShift pod",
    "CreateContainerError": "container creation error OpenShift",
    "RunContainerError": "run container error OpenShift pod",
    "OOMKilled": "OOMKilled pod memory OpenShift",
    "Evicted": "pod evicted OpenShift cluster",
    "FailedScheduling": "pod scheduling failure OpenShift",
    "NodeNotReady": "node not ready OpenShift cluster",
    "NetworkNotReady": "network not ready OpenShift",
    "PersistentVolumeClaimNotBound": "PVC not bound OpenShift storage",
    "VolumeAttachFailed": "volume attachment failure OpenShift",
}

def extract_failure_reason(pod, pod_logs: str) -> str:
    """
    Extract the failure reason from pod status and logs
    Returns a string describing the failure
    
    Based on Robusta's PodEvent structure:
    - pod.status.containerStatuses (camelCase)
    - container_status.state.waiting.reason
    - container_status.state.terminated.reason
    
    Reference: https://github.com/robusta-dev/robusta/blob/master/src/robusta/integrations/kubernetes/autogenerated/events.py
    """
    try:
        # Check container statuses (Robusta uses camelCase: containerStatuses)
        if pod.status and hasattr(pod.status, 'containerStatuses') and pod.status.containerStatuses:
            for container_status in pod.status.containerStatuses:
                # Check waiting state first (more common for ongoing issues)
                if (container_status.state and 
                    container_status.state.waiting and 
                    container_status.state.waiting.reason):
                    reason = container_status.state.waiting.reason
                    if reason in PROMPT_MAPPINGS:
                        return reason
                
                # Check terminated state
                if (container_status.state and 
                    container_status.state.terminated and 
                    container_status.state.terminated.reason):
                    reason = container_status.state.terminated.reason
                    if reason in PROMPT_MAPPINGS:
                        return reason
        
        # Check pod conditions as fallback
        if pod.status and hasattr(pod.status, 'conditions') and pod.status.conditions:
            for condition in pod.status.conditions:
                if (hasattr(condition, 'status') and 
                    hasattr(condition, 'reason') and
                    condition.status == "False" and 
                    condition.reason and
                    condition.reason in PROMPT_MAPPINGS):
                    return condition.reason
                    
    except AttributeError as e:
        # Log the specific attribute error for debugging
        print(f"AttributeError while parsing pod status: {e}")
    except Exception as e:
        # Catch any other unexpected errors
        print(f"Unexpected error parsing pod status: {e}")
    
    # Parse logs for common error patterns as final fallback
    if pod_logs:
        log_lower = pod_logs.lower()
        if "out of memory" in log_lower or "oom" in log_lower:
            return "OOMKilled"
        elif "image pull" in log_lower or "imagepullbackoff" in log_lower:
            return "ImagePullBackOff"
        elif "crashloopbackoff" in log_lower or "crash loop" in log_lower:
            return "CrashLoopBackOff"
        elif "evicted" in log_lower:
            return "Evicted"
    
    # Default to CrashLoopBackOff if we can't determine
    return "CrashLoopBackOff"

def query_sreips_agent(query: str) -> dict:
    """
    Call the SREIPS Agent API with the given query
    Returns the combined results or error message
    """
    try:
        response = requests.post(
            f"{SREIPS_AGENT_URL}/query",
            json={"query": query},
            timeout=600
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.Timeout:
        return {"combined_results": "Error: Request to SREIPS Agent timed out"}
    except requests.exceptions.ConnectionError:
        return {"combined_results": f"Error: Could not connect to SREIPS Agent at {SREIPS_AGENT_URL}"}
    except Exception as e:
        return {"combined_results": f"Error querying SREIPS Agent: {str(e)}"}

def convert_markdown_to_slack(text: str) -> str:
    """
    Convert standard markdown to Slack-compatible markdown
    - **bold** ‚Üí *bold* (Slack uses single asterisks for bold)
    - Keep bullets and numbered lists as-is
    - Preserve code blocks with backticks
    """
    # Convert double asterisks (standard markdown bold) to single asterisks (Slack bold)
    text = re.sub(r'\*\*([^\*]+)\*\*', r'*\1*', text)
    
    # Ensure proper spacing around bullets for better readability
    text = re.sub(r'^\*\s+', '‚Ä¢ ', text, flags=re.MULTILINE)
    
    return text

def parse_combined_results(combined_results: str) -> tuple:
    """
    Parse the combined results from SREIPS Agent into RAG and MCP sections
    Returns (rag_results, mcp_results) tuple, both converted to Slack markdown
    """
    try:
        # Split by section headers
        if "=== RAG Results ===" in combined_results and "=== MCP Results ===" in combined_results:
            parts = combined_results.split("=== MCP Results ===")
            rag_part = parts[0].replace("=== RAG Results ===", "").strip()
            mcp_part = parts[1].strip() if len(parts) > 1 else ""
            
            # Convert to Slack markdown format
            rag_part = convert_markdown_to_slack(rag_part)
            mcp_part = convert_markdown_to_slack(mcp_part)
            
            return rag_part, mcp_part
        else:
            # If no sections found, return all as RAG results
            converted = convert_markdown_to_slack(combined_results)
            return converted, ""
    except Exception as e:
        print(f"Error parsing combined results: {e}")
        return combined_results, ""

@action
def lls_agent_action(event: PodEvent):
    # we have full access to the pod on which the alert fired
    pod = event.get_pod()
    pod_name = pod.metadata.name
    pod_namespace = pod.metadata.namespace
    
    # Try to get logs, but handle cases where container hasn't started yet
    # (e.g., ImagePullBackOff, ContainerCreating, etc.)
    try:
        pod_logs = pod.get_logs()
    except Exception as e:
        print(f"Could not fetch logs for pod {pod_name} (container may not be running yet): {e}")
        pod_logs = ""
    
    # Extract failure reason from pod status and logs
    failure_reason = extract_failure_reason(pod, pod_logs)
    
    # Get the appropriate prompt
    prompt = PROMPT_MAPPINGS.get(failure_reason, PROMPT_MAPPINGS["CrashLoopBackOff"])
    
    # Query the SREIPS Agent
    results = query_sreips_agent(prompt)
    combined_results = results.get("combined_results", "No results returned from SREIPS Agent")
    
    # Parse the results into separate sections
    rag_results, mcp_results = parse_combined_results(combined_results)
    
    # Build enrichment blocks
    enrichment_blocks = [
        MarkdownBlock(f"*üö® Alert:* Pod `{pod_name}` in namespace `{pod_namespace}` is experiencing issues"),
        MarkdownBlock(f"*üîç Detected Issue:* `{failure_reason}`"),
        DividerBlock(),
    ]
    
    # Add RAG results if available
    if rag_results:
        enrichment_blocks.append(
            MarkdownBlock(f"*üìö Knowledge Base Resolution:*\n{rag_results}")
        )
        enrichment_blocks.append(DividerBlock())
    
    # Add MCP results if available
    if mcp_results:
        enrichment_blocks.append(
            MarkdownBlock(f"*üîó Red Hat KCS Articles:*\n{mcp_results}")
        )
    
    # Send enrichment to destinations
    event.add_enrichment(enrichment_blocks)